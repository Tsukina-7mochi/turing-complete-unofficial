<!doctype html><html lang="en"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css" integrity="sha384-KiWOvVjnN8qwAZbuQyWDIbfCLFhLXNETzBQjA/92pIowpC0d2O3nppDGQVgwd2nB" crossorigin="anonymous"><title>fast_adder | Turing Complete Unofficial</title><script src="main.bundle.js"></script></head><body><header><div class="menu-button"><span class="material-icons md-36">&#xE5D2;</span></div><div class="title"><a href="#">Turing Complete Unofficial</a></div><div class="search"></div></header><div class="menu"><nav><ul><li><a href="index.html" class="page-link">トップページ</a></li><li><a href="https://github.com/Tsukina-7mochi/turing-complete-unofficial/blob/9a1baa0d5011e5aed55121634f8d894c1722b92e/LICENSE" class="page-link">ライセンス</a></li><li><a href="https://github.com/Tsukina-7mochi/turing-complete-unofficial" class="page-link">プロジェクトのレポジトリ</a></li><li><a href="https://turingcomplete.game" class="page-link">公式サイト</a></li></ul><h2 class="menu-title">レベル解説</h2><nav><h3 class="menu-title collapsible-controller">BASIC LOGIC<span class="material-icons">&#xE5CF;</span></h3><nav class="collapsible"><ul><li><a href="crude_awakening.html" class="page-link">Crude Awakening</a></li><li><a href="nand_gate.html" class="page-link">NAND Gate</a></li><li><a href="not_gate.html" class="page-link">NOT Gate</a></li><li><a href="and_gate.html" class="page-link">AND Gate</a></li><li><a href="nor_gate.html" class="page-link">NOR Gate</a></li><li><a href="or_gate.html" class="page-link">OR Gate</a></li><li><a href="always_on.html" class="page-link">Always On</a></li><li><a href="second_tick.html" class="page-link">Second Tick</a></li><li><a href="xor_gate.html" class="page-link">XOR Gate</a></li><li><a href="bigger_or_gate.html" class="page-link">Bigger OR Gate</a></li><li><a href="bigger_and_gate.html" class="page-link">Bigger AND Gate</a></li><li><a href="xnor_gate.html" class="page-link">XNOR Gate</a></li></ul></nav><h3 class="menu-title collapsible-controller">ARITHMETIC<span class="material-icons">&#xE5CF;</span></h3><nav class="collapsible"><ul><li><a href="binary_racer.html" class="page-link">Binary Racer</a></li><li><a href="double_trouble.html" class="page-link">Double Trouble</a></li><li><a href="odd_number_of_signals.html" class="page-link">Odd Number of Signals</a></li><li><a href="counting_signals.html" class="page-link">Counting Signals</a></li><li><a href="half_adder.html" class="page-link">Half Adder</a></li><li><a href="byte_or.html" class="page-link">Byte OR</a></li><li><a href="byte_not.html" class="page-link">Byte NOT</a></li><li><a href="adding_bytes.html" class="page-link">Adding Bytes</a></li><li><a href="negative_numbers.html" class="page-link">Negative Numbers</a></li><li><a href="signed_negator.html" class="page-link">Signed Negator</a></li><li><a href="1_bit_decoder.html" class="page-link">1 Bit Decoder</a></li><li><a href="3_bit_decoder.html" class="page-link">3 Bit Decoder</a></li><li><a href="one_way.html" class="page-link">One Way</a></li></ul></nav><h3 class="menu-title collapsible-controller">MEMORY<span class="material-icons">&#xE5CF;</span></h3><nav class="collapsible"><ul><li><a href="circular_dependency.html" class="page-link">Circular Dependency</a></li><li><a href="delayed_lines.html" class="page-link">Delayed Lines</a></li><li><a href="odd_ticks.html" class="page-link">Odd Ticks</a></li><li><a href="bit_switch.html" class="page-link">Bit Switch</a></li><li><a href="saving_gracefully.html" class="page-link">Saving Gracefully</a></li><li><a href="sr_latch.html" class="page-link">SR Latch</a></li><li><a href="bit_inverter.html" class="page-link">Bit Inverter</a></li><li><a href="input_selector.html" class="page-link">Input Selector</a></li><li><a href="the_bus.html" class="page-link">The Bus</a></li><li><a href="saving_bytes.html" class="page-link">Saving Bytes</a></li><li><a href="little_box.html" class="page-link">Little Box</a></li><li><a href="counter.html" class="page-link">Counter</a></li></ul></nav><h3 class="menu-title collapsible-controller">CPU ARCHITECTURE<span class="material-icons">&#xE5CF;</span></h3><nav class="collapsible"><ul><li><a href="logic_engine.html" class="page-link">Logic Engine</a></li><li><a href="arithmetic_engine.html" class="page-link">Arithmetic Engine</a></li><li><a href="registers.html" class="page-link">Registers</a></li><li><a href="component_factory.html" class="page-link">Component Factory</a></li><li><a href="instruction_decoder.html" class="page-link">Instruction Decoder</a></li><li><a href="calculations.html" class="page-link">Calculations</a></li><li><a href="conditions.html" class="page-link">Conditions</a></li><li><a href="program.html" class="page-link">Program</a></li><li><a href="immediate_values_cpu_architecture.html" class="page-link">Immediate Values (CPU ARCHITECTURE)</a></li><li><a href="turing_complete.html" class="page-link">Turing Complete</a></li></ul></nav><h3 class="menu-title collapsible-controller">PROGRAMMING<span class="material-icons">&#xE5CF;</span></h3><nav class="collapsible"><ul><li><a href="add_5.html" class="page-link">Add 5</a></li><li><a href="calibrating_laser_cannons.html" class="page-link">Calibrating Laser Cannons</a></li><li><a href="spacial_invasion.html" class="page-link">Spacial Invasion</a></li><li><a href="storage_cracker.html" class="page-link">Storage Cracker</a></li><li><a href="masking_time.html" class="page-link">Masking Time</a></li><li><a href="the_maze.html" class="page-link">The Maze</a></li></ul></nav><h3 class="menu-title collapsible-controller">CPU ARCHITECTURE 2<span class="material-icons">&#xE5CF;</span></h3><nav class="collapsible"><ul><li><a href="xor.html" class="page-link">XOR</a></li><li><a href="byte_constant.html" class="page-link">Byte Constant</a></li><li><a href="byte_xor.html" class="page-link">Byte XOR</a></li><li><a href="equality.html" class="page-link">Equality</a></li><li><a href="unsigned_less.html" class="page-link">Unsigned Less</a></li><li><a href="signed_less.html" class="page-link">Signed Less</a></li><li><a href="wide_instructions.html" class="page-link">Wide Instructions</a></li><li><a href="wire_spaghetti.html" class="page-link">Wire Spaghetti</a></li><li><a href="opcodes.html" class="page-link">Opcodes</a></li><li><a href="immediate_values_cpu_architecture_2.html" class="page-link">Immediate Values (CPU ARCHITECTURE 2)</a></li><li><a href="conditionals.html" class="page-link">Conditionals</a></li></ul></nav><h3 class="menu-title collapsible-controller">FUNCTIONS<span class="material-icons">&#xE5CF;</span></h3><nav class="collapsible"><ul><li><a href="the_sandbox.html" class="page-link">The Sandbox</a></li><li><a href="the_lab.html" class="page-link">The Lab</a></li><li><a href="delay.html" class="page-link">Delay</a></li><li><a href="shift.html" class="page-link">Shift</a></li><li><a href="the_product_of_nibbles.html" class="page-link">The Product of Nibbles</a></li><li><a href="ram.html" class="page-link">RAM</a></li><li><a href="divide.html" class="page-link">Divide</a></li><li><a href="stack.html" class="page-link">Stack</a></li><li><a href="push_and_pop.html" class="page-link">PUSH and POP</a></li><li><a href="functions.html" class="page-link">Functions</a></li></ul></nav><h3 class="menu-title collapsible-controller">ASSEMBLY CHALLENGES<span class="material-icons">&#xE5CF;</span></h3><nav class="collapsible"><ul><li><a href="ai_showdown.html" class="page-link">AI Showdown</a></li><li><a href="robot_racing.html" class="page-link">Robot Racing</a></li><li><a href="unseen_fruit.html" class="page-link">Unseen Fruit</a></li><li><a href="delicious_order.html" class="page-link">Delicious Order</a></li><li><a href="dancing_machine.html" class="page-link">Dancing Machine</a></li><li><a href="tower_of_alloy.html" class="page-link">Tower Of Alloy</a></li><li><a href="planet_names.html" class="page-link">Planet Names</a></li><li><a href="water_world.html" class="page-link">Water World</a></li></ul></nav></nav><h2 class="menu-title collapsible-controller">実績<span class="material-icons">&#xE5CF;</span></h2><nav class="collapsible"><ul><li><a href="4_nand_equals_xor.html" class="page-link">4 NAND = XOR</a></li><li><a href="condition_10.html" class="page-link">Condition 10</a></li><li><a href="turing_complete_achievement.html" class="page-link">Turing Complete (実績)</a></li><li><a href="helperbot.html" class="page-link">Helperbot</a></li><li><a href="5_component_full_adder.html" class="page-link">5 Component Full Adder</a></li><li><a href="fast_adder.html" class="page-link">Fast Adder</a></li><li><a href="tutorial_complete.html" class="page-link">Tutorial Complete</a></li><li><a href="fast_bot.html" class="page-link">Fast Bot</a></li><li><a href="symmetric_alu.html" class="page-link">Symmetric ALU</a></li><li><a href="3_adder_multiply.html" class="page-link">3 Adder Multiply</a></li><li><a href="binary_counter.html" class="page-link">Binary Counter</a></li></ul><h3 class="menu-title collapsible-controller">隠し実績<span class="material-icons">&#xE5CF;</span></h3><nav class="collapsible"><ul><li><a href="best_hat.html" class="page-link">Best hat</a></li><li><a href="black_hat.html" class="page-link">Black hat</a></li><li><a href="binary_racer_achievement.html" class="page-link">Binary Racer (実績)</a></li></ul></nav></nav></nav></div><main><h1><a href="#fast-adder" aria-hidden="true" class="anchor" id="fast-adder"></a>Fast Adder</h1><h2><a href="#" aria-hidden="true" class="anchor" id=""></a>レベル</h2><p><a class="page-link" href="adding_bytes.html">Adding Bytes</a></p><h2><a href="#" aria-hidden="true" class="anchor" id=""></a>取得条件</h2><blockquote><p>Complete the byte adder with a delay of 36 or less</p></blockquote><p>(遅延36以下の回路のByte Adderを構成しステージをクリアする)</p><h2><a href="#" aria-hidden="true" class="anchor" id=""></a>攻略・解答</h2><h3><a href="#" aria-hidden="true" class="anchor" id=""></a>問題点の整理</h3><p>加算機の高速化を考えます。</p><p>まず、FAを利用した加算機は次のようになっていました。</p><p><img alt="" src="https://gyazo.com/b70cef44e75aacf74df0c35a43bc37c5.png"></p><p>この回路は遅延スコアが64となっています。 この回路のクリティカルパス (遅延が最も大きい経路) は、 画像中に赤色で示したCarryの伝播の部分で、 FAの遅延が8で全体が8段あるため64遅延となっているわけです。</p><p>したがってこの部分を解消すれば高速化できそうです。</p><h3><a href="#cla" aria-hidden="true" class="anchor" id="cla"></a>CLA入門</h3><p>ここで、FAの回路をもう一度確認してみると、次のようになっていました。</p><p><img alt="" src="https://gyazo.com/2555d2b7e34e906bc4c74b6bfdda2e21.png"></p><p>これを見ると、Sumの計算は8遅延であるのに対し、 Carryの計算は6遅延で済むことがわかります。</p><p>したがって、Sumの結果を待たずにCarryを伝播させれば 1段あたり2遅延分の高速化ができることがわかります。</p><p>実際にこれを実装したものが次の画像に示す回路で、 遅延スコアは48と、16減少しています。</p><p><img alt="" src="https://gyazo.com/d932dd39906e4bb46e1802f0fda792c8.png"></p><h3><a href="#carry" aria-hidden="true" class="anchor" id="carry"></a>Carry計算のさらなる高速化</h3><p>しかし実績の解除条件は36遅延以下であるため、 ただFAの回路を展開しただけでは十分な高速化ができていません。</p><p>そこで、Carryの計算をさらに高速に行う方法を考えます。</p><h3><a href="#carry" aria-hidden="true" class="anchor" id="carry"></a>Carryを考える</h3><p>ここで、一度Carryの計算方法を考え直していきます。 なお、下の桁からのCarry入力を<x-equation>c</x-equation>、入力2つを<x-equation>a</x-equation>、<x-equation>b</x-equation>、 Carry出力を<x-equation>C</x-equation>と表記します (ブール代数の表記については <a href="#bool_algebra">ブール代数</a> のページを参照)。</p><p>現在の回路では次のようにしてCarryを計算しています。</p><p><x-equation type="display">C = (a + b) \cdot (a + c) \cdot (b + c)</x-equation></p><p>これは次の式と等価です。</p><p><x-equation type="display">\begin{align*} C =&amp; (a \cdot b) + (a \cdot c) + (b \cdot c) \\ =&amp; (a \cdot b) + ((a + b) \cdot c) \tag{1} \end{align*}</x-equation></p><p>この式は、次のように解釈することができます。</p><p><x-equation type="display">C = \left\{ \begin{array}{ll} 1 &amp; (a \cdot b = 1) \\ c &amp; (a \cdot b \neq 1 \land a + b = 1) \\ 0 &amp; otherwise \end{array} \right.</x-equation></p><p>すなわち、</p><ul><li><x-equation>a</x-equation>と<x-equation>b</x-equation>が両方 <span class="T">True</span> であれば<x-equation>C = 1</x-equation></li><li>どちらが一方が <span class="T">True</span> であれば<x-equation>C = c</x-equation></li><li>どちらも <span class="F">False</span> であれば<x-equation>C = 0</x-equation></li></ul><p>ということが<x-equation>a</x-equation>と<x-equation>b</x-equation>のみから決定されます。</p><p>ここで<x-equation>G</x-equation>(Generate) 、<x-equation>P</x-equation>(Pass) を<x-equation>G = a \cdot b, P = a + b</x-equation>と定義します。 すると、</p><ul><li><x-equation>G</x-equation>が <span class="True">True</span> ならば<x-equation>C = 1</x-equation></li><li><x-equation>P</x-equation>が <span class="True">True</span> ならば<x-equation>C = c</x-equation></li></ul><p>と言うことができます。</p><p>次に、<x-equation>n</x-equation>段の場合を考えます。このとき<x-equation>i</x-equation>段目の各記号を<x-equation>a_i, b_i, c_i, C_i, G_i, P_i</x-equation>と表すことにします。<x-equation>(1)</x-equation>式を再帰的に展開していくと、次のようになります (数式はしっかり見なくても大丈夫です)。</p><pre><code class="language-latex"><x-equation type="display">
\begin{align*}
C_i
=&amp; (a_i \cdot b_i) + ((a_i + b_i) \cdot c_i) \\
=&amp; G_i + P_i \cdot c_i \\
=&amp; G_i + P_i \cdot (G_{i-1} + P_{i-1} \cdot c_{i-1})
=  G_i + P_i \cdot G_{i-1} + P_i \cdot P_{i-1} \cdot c_{i-1} \\
=&amp; G_i + P_i \cdot G_{i-1} + P_i \cdot P_{i-1} \cdot G_{i-2} + P_i \cdot P_{i-1} \cdot P_{i-2} + c_{i-2} \\
&amp; \cdots \\
=&amp; G_i + \Sigma^{i-1}_{k=0} (\Pi^{i}_{l=i-k} P_l) \cdot G_{i-k-1} + (\Pi^{i}_{l=0} P_l) \cdot c_{-1}
\end{align*}

</x-equation></code></pre><p>これは、<x-equation>i</x-equation>段目について次のことを意味します (ただし上の行の条件が優先されるとします)。</p><p><x-equation type="display">C_i = \left\{ \begin{array}{ll} 1 &amp; (G_i = 1) \\ 1 &amp; (P_i = 1 \land G_{i-1} = 1) \\ 1 &amp; (P_i = P_{i-1} = 1 \land G_{i-2} = 1) \\ \cdots \\ c_{-1} &amp; (P_i = P_{i-1} = \cdots = P_0 = 1) \\ 0 &amp; otherwise \end{array} \right.</x-equation></p><p>これは、次のように解釈できます。</p><ul><li>その桁の<x-equation>G</x-equation>が <span class="T">True</span> ならば、<x-equation>C = 1</x-equation></li><li>そうでなくても、その桁の<x-equation>P</x-equation>が <span class="T">True</span> で その下の桁の<x-equation>G</x-equation>が <span class="T">True</span> ならば、<x-equation>C = 1</x-equation></li><li>そうでなくても、さらにその下の桁の<x-equation>P</x-equation>が<span class="T">True</span> で その下の桁の<x-equation>G</x-equation>が <span class="T">True</span> ならば、<x-equation>C = 1</x-equation></li><li>...</li><li>そうでなくても、下の桁全部の<x-equation>P</x-equation>が<span class="T">True</span> ならば、<x-equation>C = c_i</x-equation></li></ul><p>ここで、<x-equation>c_{-1}</x-equation>は加算器自体へのCarry入力とします (これは一般化して下の桁の<x-equation>G</x-equation>と考えることもできます)。</p><p>つまり、<x-equation>C_i</x-equation>を求めるには、<x-equation>P_i, P_{i-1}, P_{i-2}, ..., P_0</x-equation>が わかればよいということです。</p><h3><a href="#cla-carry" aria-hidden="true" class="anchor" id="cla-carry"></a>CLAにおけるCarryの計算コスト</h3><p>先程の節で、<x-equation>C_i</x-equation>を求めるには<x-equation>P_i, P_{i-1}, P_{i-2}, ..., P_0</x-equation>の 論理積を取ればよいということがわかりました。</p><p>今までのCLAでは、この演算を逐次追加的に行ってきていました (すなわち<x-equation>i</x-equation>桁目で計算した<x-equation>P_i \cdot P_{i-1} \cdots P_0</x-equation>に対して<x-equation>P_{i+1}</x-equation>の論理積を計算していました)。 この場合、<x-equation>C_n</x-equation>の計算を行うためには<x-equation>n</x-equation>回の論理積を取ることになります。 ANDゲートの遅延は2であるため、遅延スコアは<x-equation>O(n)</x-equation>となります。</p><p>一方、<x-equation>n</x-equation>個のAND演算はもっと高速に行うことができます。 論理積は結合則が成り立つため、<x-equation>n</x-equation>個のAND演算 →<x-equation>n/2</x-equation>個のAND演算 →<x-equation>n/4</x-equation>個のAND演算 → ... のように減らしていくことができ、 AND演算の回数は<x-equation>\lceil log_2(n) \rceil</x-equation>となります (<x-equation>\lceil\cdot\rceil</x-equation>は切り上げを意味します) 。 すなわち、効率よく計算を行った場合遅延コストは<x-equation>O(log(n))</x-equation>となります (基数は省略)。すなわち今までのCLAでは64bitの加算をするのに1bitの加算の64倍の遅延が 発生していましたが、新しい方法では8倍で済むということです。</p><p>ただし、この方法にも欠点はあり、ANDゲートの数が<x-equation>O(n^2)</x-equation>で増加し、 それに従って回路面積も増えていくため回路の構築が困難になります。 そこで、これらの方法を併用することにします。 すなわち<x-equation>N</x-equation>段の加算を行うために<x-equation>n</x-equation>個のCLAを<x-equation>\lceil N/n\rceil</x-equation>個 直列に接続するという方法です。 この場合の遅延スコアは1段の加算に比べて<x-equation>\lceil N/n\rceil log(n)</x-equation>倍となります。 今回の場合は<x-equation>N=8</x-equation>であり、1段の加算の遅延スコアが8であるため4倍に抑えたい ところです。したがって<x-equation>2 \leq n \leq 4</x-equation>の範囲で選択すればよいことがわかります。</p><p>なお、<x-equation>n=2</x-equation>では端数の関係で<x-equation>n=2</x-equation>ではうまく構成できなかったため、<x-equation>n=4</x-equation>で構成することにします。</p><h3><a href="#" aria-hidden="true" class="anchor" id=""></a>回路の構成</h3><p>各桁の<x-equation>G, P</x-equation>は単純に各桁のAND, OR演算を取ることで求められます。 これらを事前に準備した状態で各桁のCarryの計算を考えます。</p><p><x-equation type="display">\begin{align*} C_0 =&amp; G_0 + P_0 \cdot c_{-1} \\ C_1 =&amp; G_1 + P_1 \cdot G_0 + P_1 \cdot P_0 \cdot c-{-1} \\ C_2 =&amp; G_2 + P_2 \cdot G_1 + P_2 \cdot P_1 \cdot G_0 + P_2 \cdot P_1 \cdot P_0 \cdot c_{-1} \\ C_3 =&amp; G_3 + P_3 \cdot G_2 + P_3 \cdot P_2 \cdot G_1 + P_3 \cdot P_2 \cdot P_1 \cdot G_0 + P_3 \cdot P_2 \cdot P_1 \cdot P_0 \cdot c_{-1} \\ \end{align*}</x-equation></p><p><x-equation>P_i</x-equation>同士のAND演算で出現しているものは次の6通りです。</p><p><x-equation type="display">\{ P_0 P_1, P_1 P_2, P_2 P_3, P_0 P_1 P_2, P_1 P_2 P_3, P_0 P_1 P_2 P_3 \}</x-equation></p><p>したがって、<x-equation>P_0 P_1, P_1 P_2, P_2 P_3</x-equation>を予め用意しておけば ゲートの数を抑えることができそうです。</p><p>各桁のSumは、今までと同様に下の桁のCarryと2つの入力の XORを取ることで求めることができます。</p><p>これを実装した回路を次の画像に示します。</p><p><img alt="" src="https://gyazo.com/594afc9855b76a0a1136071a3477b6e8.png"></p><p>見事遅延スコアが32と、36以下に抑えることができました。 お疲れさまでした。</p></main></body></html>